// Useful to sort lists by a custom key
import java.util.Comparator;
import java.util.HashMap;
import java.util.Random;
import java.util.*;
/// In this file you will implement your navmesh and pathfinding. 


/// This node representation is just a suggestion
class Node
{
   int id;
   ArrayList<Wall> polygon;
   PVector center;
   ArrayList<Node> neighbors;
   ArrayList<Wall> connections;
   
   Node(int id, PVector center){
    this.id = id;
    this.center = center;
    neighbors = new ArrayList<Node>();
    connections = new ArrayList<Wall>();
    
    polygon = createBorder(center, 75);
  }
  
  void AddNeighbor(Node NewNeighbor){
    neighbors.add(NewNeighbor);
    connections.add(new Wall(this.center, NewNeighbor.center));
  }
  
  //Extra code to help sample the polygons with walls
    ArrayList<Wall> createBorder(PVector center, float border){
    ArrayList<Wall> borders = new ArrayList<Wall>();
    
    PVector topLeft = new PVector(center.x - border, center.y - border);
    PVector bottomLeft = new PVector(center.x - border, center.y + border);
    PVector bottomRight = new PVector(center.x + border, center.y + border);
    PVector topRight = new PVector(center.x + border, center.y - border);
    
    borders.add(new Wall(topLeft, bottomLeft));
    borders.add(new Wall(bottomLeft, bottomRight));
    borders.add(new Wall(bottomRight, topRight));
    borders.add(new Wall(topRight, topLeft));
    
    return borders;
  }
}



class NavMesh
{   
   public ArrayList<PVector> ReflexPoints;  //Reflex points that need to be adjusted
   public ArrayList<Wall> NewWalls;      //Walls that have been added to split polygon to be convex
   public ArrayList<Node> RandData;      //Artificially created data
   public ArrayList<PVector> holyGrail;  //path to be followed
   
   //HashMap<Integer, Wall> NewWallsMap = new HashMap<Integer, Wall>();   //possible option for creating wall, or a class could extend it to give the wall an ID?
   
   
   void bake(Map map)
   {
     
      //Creating a couple nodes and connections for artificial testing
      RandData = new ArrayList<Node>();
      RandData.add(new Node(0, new PVector(50, 490)));
      RandData.add(new Node(1, new PVector(500, 100)));
      RandData.add(new Node(2, new PVector(230, 500)));
      RandData.add(new Node(3, new PVector(20, 30)));
      RandData.add(new Node(4, new PVector(750, 300)));
      RandData.add(new Node(5, new PVector(400, 300)));
      
      RandData.get(0).AddNeighbor(RandData.get(2));
      RandData.get(2).AddNeighbor(RandData.get(0));
      RandData.get(0).AddNeighbor(RandData.get(3));
      RandData.get(3).AddNeighbor(RandData.get(0));
      RandData.get(1).AddNeighbor(RandData.get(4));
      RandData.get(4).AddNeighbor(RandData.get(1));
      RandData.get(5).AddNeighbor(RandData.get(3));
      RandData.get(3).AddNeighbor(RandData.get(5));
      RandData.get(1).AddNeighbor(RandData.get(5));
      RandData.get(5).AddNeighbor(RandData.get(1));
      RandData.get(2).AddNeighbor(RandData.get(5));
      RandData.get(5).AddNeighbor(RandData.get(2));
      RandData.get(4).AddNeighbor(RandData.get(2));
      RandData.get(2).AddNeighbor(RandData.get(4));
      
       ArrayList<Wall> Walls = map.walls;
       NewWalls = new ArrayList<Wall>();
       ReflexPoints = new ArrayList<PVector>();
       
       //Checking for reflex points, likely not required when code is finished
       if(Walls != null){
         for(int i = 0; i<Walls.size(); ++i){
           int next = (i+1)%Walls.size();
           if(Walls.get(i).normal.dot(Walls.get(next).direction) >= 0)
           {
             ReflexPoints.add(Walls.get(i).end);
             //circle (ReflexPoints.get(ReflexPoints.size()-1).x, ReflexPoints.get(ReflexPoints.size()-1).y, 20);
           }
         }
       } 
    
            
       //might add and if reflexive != null
       if (ReflexPoints.size() > 0){
         Split(Walls);  //recursively splits the walls and will add everything to public memory
       }
             
 
     //finding path between the start and a designated point here, issue with calling it from boid seek
     holyGrail = new ArrayList<PVector>();
     holyGrail = findPath(billy.kinematic.position, new PVector(760, 310));
     
     //prints out the path generated by A*
     print("\n Path in order\n");
     for(int i = 0; i < holyGrail.size(); i++){
        print((i + 1)+ " Point: is at " + holyGrail.get(i));
        print("\n");
      }
   }
   
   void Split(ArrayList<Wall> PolygonWalls)
   {
     
     //print("Printing a wall list");
     //PrintWallCoords(PolygonWalls);
     
     //find first reflexive point to split off from
     int ReflexPointNumber = -1;
     boolean Convex = true;
     
     
     for(int i = 0; i<PolygonWalls.size(); ++i){
           int next = (i+1)%PolygonWalls.size();
           if(PolygonWalls.get(i).normal.dot(PolygonWalls.get(next).direction) >= 0)
           {
             print("\nReflex found");
             ReflexPointNumber = next;
             Convex = false;
             break;
           }
         }
     print("\nReflex Point Number: " + ReflexPointNumber);    
     
     
     if(Convex){
       print("\nFound Convex Polygon");
       //Create new polygon, no reflex points found
     }  else { //Going to need to split it again
     
       PVector ReflexPoint = PolygonWalls.get(ReflexPointNumber).start;
       
       //Need to find a point to fix at
       int FixPointNumber = 0;    //just need to initialize these variables, a valid fix point should always be found in our loop
       PVector FixPoint = ReflexPoint;
       
       int PointGap = 2;      //Points between start and fix, starts by skipping the point we know is reflex already
       boolean Reachable = false;
       boolean Reflexive = true;
       
       while(Reachable == false || Reflexive == false){
         FixPointNumber = (ReflexPointNumber+PointGap)%PolygonWalls.size();  //Uses the next available point so it is a very simple iteration through all the points, and there will always be at least one point that fulfills both requirements
         FixPoint = PolygonWalls.get(FixPointNumber).start;
         Wall TestWall = new Wall(ReflexPoint, FixPoint);
         
         //Checks if the new edge would actually interfere with any existing walls
         Reachable = IsPlaceable(PolygonWalls, TestWall);
         
         //using the % wasn't working before so I added this to get the previous wall even if it was the first wall in the list
         int Previous = (ReflexPointNumber-1);
         if(Previous <0){
           Previous = PolygonWalls.size() -1;
         }
         if(PolygonWalls.get(Previous).normal.dot(TestWall.direction) >= 0){    //Checks if the new wall will fix the initial reflexive point
           Reflexive = false;
         }else{
           Reflexive = true;
          //print("\nA non reflexive wall could be formed between points " + ReflexPointNumber + " and " + FixPointNumber);
         }
         
         PointGap += 1;  //if the first point doesnt work, then it will go to the next point
       }

       print("\nSplitting the polygon between points " + ReflexPoint + ", " + FixPoint);
       
       //makes sure that in the order list of walls, the reflex point comes before so both new polygons are properly directioned and ordered
       if(FixPointNumber < ReflexPointNumber){
         int temp = FixPointNumber;
         FixPointNumber = ReflexPointNumber;
         ReflexPointNumber = temp;
         ReflexPoint = PolygonWalls.get(ReflexPointNumber).start;
         FixPoint = PolygonWalls.get(FixPointNumber).start;
       }
       
       //Two walls needed so each polygon has ordered walls going counter clockwise
       Wall Normal = new Wall(ReflexPoint, FixPoint);
       Wall Reverse = new Wall(FixPoint, ReflexPoint);
                   
       //Walls split between 2 polygons
       ArrayList<Wall> FrontWalls = new ArrayList<Wall>();
       ArrayList<Wall> BackWalls = new ArrayList<Wall>(); 
       BackWalls.add(Reverse);
                   
       for(int r = 0; r<PolygonWalls.size(); r++){
           
         
           if(r >= ReflexPointNumber && r < FixPointNumber){
             BackWalls.add(PolygonWalls.get(r));
             //print("\nAdding to backwall wall: " + r);
           } else{
             FrontWalls.add(PolygonWalls.get(r));
             //print("\nAdding to frontwall wall: " + r);
           }
         
       }
       FrontWalls.add(ReflexPointNumber, Normal);
       
       //Adding the new wall to a list or later use/recursion
       NewWalls.add(Normal);   
       
       //Splits both new polygons
       print("\nPrinting the front wall list");
       PrintWallCoords(FrontWalls);
       //print("\nSplitting the front Wall");
       Split(FrontWalls);
       
       
       //print("\nPrinting the back wall list");
       //PrintWallCoords(BackWalls);
       //print("\nSplitting the back Wall");
       Split(BackWalls);
       
       //Add proper connections/neighbors
     }
   }  
   
   Boolean IsPlaceable (ArrayList<Wall> PolygonWalls, Wall TestWall){
     PVector From = PVector.add(TestWall.start, PVector.mult(TestWall.direction, 0.01));
     PVector To = PVector.add(TestWall.end, PVector.mult(TestWall.direction, -0.01));
     for(int n = 0; n<PolygonWalls.size(); n++){      //checks all walls to see if there is any crossing
           if(PolygonWalls.get(n).crosses(From, To)){
             return false;
           }
         }
     return true;
   }
   
   class frontierNode{
     float heuristic;
     float pathLength;
     float aValue;
     Node currentNode;
     frontierNode parentNode;
     
     frontierNode(Node currentNode, frontierNode parentNode, float pathLength, PVector target){
       this.currentNode = currentNode;
       this.parentNode = parentNode;
       this.pathLength = pathLength;
       this.heuristic = getPVectorDistance(currentNode.center, target);
       this.aValue = pathLength + heuristic;
     }
   }
   
   ArrayList<PVector> findPath(PVector boidPosition, PVector destinationPosition)
   {
     ArrayList<PVector> path = new ArrayList<PVector>();
    
     //find which nodes boid and destination are in
     Node startNode = null;
     Node endNode = null;

     for(Node testNode: RandData){     
       if(pointContained(boidPosition, testNode.polygon)){
         startNode = testNode;
         break;
       }
     }
     
     for(Node testNode: RandData){
       if(pointContained(destinationPosition, testNode.polygon)){
         endNode = testNode;
         break;
       }
     }
     
     //call find node path
     if (startNode != endNode){
       print("\nFinding path between nodes");
       path = findNodePath(startNode, endNode);
     }
     
     path.add(destinationPosition);
     path.add(0, boidPosition);
     //might combine them all into one, tbd
     
     
     return path;  
   }
   
   boolean pointContained (PVector point, ArrayList<Wall> polygon){
     //Wall infinity = new Wall(point, new PVector(point.x + 2*width, point.y));
     int crosses = 0;
     for(Wall wall: polygon){
            if (wall.crosses(point, new PVector(point.x + 2*width, point.y))){
              crosses ++;
            }
            
          }
     if((crosses % 2) == 0){
       return false;
     }
     return true;
   }
   
   //  PLEASE REMEMBER TO CHANGE THIS TO PVECTORS NOT NodeS
   ArrayList<PVector> findNodePath(Node start, Node destination)
   {
     print("\n Looking for path");
     ArrayList<frontierNode> frontierList = new ArrayList<frontierNode>();
     ArrayList<Node> previouslyExpandedList = new ArrayList<Node>();
     
     frontierList.add(new frontierNode(start, null, 0, destination.center));
     //frontierNode lastNode;
     while(frontierList.get(0).currentNode != destination){
        print("\n The current lowest node is at: " + frontierList.get(0).currentNode.center);
        for(int i = 0; i < frontierList.get(0).currentNode.neighbors.size(); i++){
          print("\n Adding Neighbors");
          float newPath = frontierList.get(0).pathLength + getPVectorDistance(frontierList.get(0).currentNode.center, frontierList.get(0).currentNode.neighbors.get(i).center);
          frontierList.add(new frontierNode(frontierList.get(0).currentNode.neighbors.get(i), frontierList.get(0), newPath, destination.center));
        }
        previouslyExpandedList.add(frontierList.get(0).currentNode);
        frontierList.remove(0);
        frontierList.sort(new FrontierCompare());
        while(previouslyExpandedList.contains(frontierList.get(0).currentNode)){
          frontierList.remove(0);
        }
        print("\n Done Sorting");
     }
     
      ArrayList<PVector> result = new ArrayList<PVector>();
      result.add(frontierList.get(0).currentNode.center);
      
      frontierNode parentNode = frontierList.get(0).parentNode;
      
      while(result.get(0) != start.center){
        result.add(0, parentNode.currentNode.center);
        parentNode = parentNode.parentNode;
      }
      
      return result;
   }
   
   class FrontierCompare implements Comparator<frontierNode>{
     int compare(frontierNode a, frontierNode b){
       print("\n Doing comparing things");
       if(a.aValue > b.aValue){
         return 1;
       } else if(a.aValue < b.aValue){
         return -1;
       } else
         return 0;
     }
   }
   
   
   
   TreeMap<Float, Node> expandFrontier(TreeMap<Float, Node>frontier, Node target){
     float shortestPath = frontier.firstKey();
     for(int i = 0; i<frontier.get(shortestPath).neighbors.size(); i++){
       float heuristic = shortestPath + getPVectorDistance(target.center, frontier.get(shortestPath).neighbors.get(i).center);
       frontier.put(heuristic, frontier.get(shortestPath).neighbors.get(i));
     }
     return frontier;
   }
   
   void update(float dt)
   {
      draw();
      
       //print("\n List all points: " + AllPoints);
       //print("\n List all reflex points: " + RPoints);
      
   }
   
   void draw()
   {
      /// use this to draw the nav mesh graph
      for(int i = 0; i < ReflexPoints.size(); i++){
        stroke(0,255,0);
        circle(ReflexPoints.get(i).x, ReflexPoints.get(i).y, 20);
      }
      
      int blueColor = 255;
      int redColor = 0;
      if(NewWalls!=null){
      for(int j = 0; j < NewWalls.size(); j++){
        stroke(redColor,0,blueColor);
        blueColor -= 10;
        redColor += 10;
        line(NewWalls.get(j).start.x, NewWalls.get(j).start.y, NewWalls.get(j).end.x, NewWalls.get(j).end.y);
          //line(current.x, current.y, current.x + 50, current.y);
      }
      }
      /*
      //print(RandData);
      if(RandData!=null){
      for(int k = 0; k < RandData.size(); k++){
        stroke(0,0,255);
        circle(RandData.get(k).center.x, RandData.get(k).center.y, 20);
        for(int l = 0; l<RandData.get(k).connections.size(); l++){
          stroke (0,0,100);
          line(RandData.get(k).connections.get(l).start.x, RandData.get(k).connections.get(l).start.y, RandData.get(k).connections.get(l).end.x, RandData.get(k).connections.get(l).end.y);
          
          for(Wall wall: RandData.get(k).polygon){
            stroke (0,0,200);
            line(wall.start.x, wall.start.y, wall.end.x, wall.end.y);
            
          }
        }
        
      }
      }
      if(holyGrail != null){
      for(int i = 0; i < holyGrail.size(); i++){
        stroke(255,0,200);
        //fill(255, 0, 0);
        circle(holyGrail.get(i).x, holyGrail.get(i).y, 20);
        //print("hi");
      }
      }
      */
   }
}
