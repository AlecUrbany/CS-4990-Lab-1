// Useful to sort lists by a custom key
import java.util.Comparator;
import java.util.HashMap;


/// In this file you will implement your navmesh and pathfinding. 
int tag = 1;


/// This node representation is just a suggestion
class Node
{
   //Pieces that make up the node, ID (for referencing) list of polygons, the center of the polygons, neighbors, and connections between polygons
   int id;
   ArrayList<Wall> polygon;
   PVector center;
   ArrayList<Node> neighbors;
   ArrayList<Wall> connections;   
   
   Node(int id, PVector center)
   {
     this.id = id;
     this.center = center;
     neighbors = new ArrayList<Node>();
     connections = new ArrayList<Wall>();
    
     polygon = createBorder(center, 75);
   }
      Node(int id, ArrayList<Wall> polygon)
   {
     this.id = id;
     this.polygon = polygon;
   }
   
   void AddNeighbor(Node NewNeighbor)
   {
     neighbors.add(NewNeighbor);
     connections.add(new Wall(this.center, NewNeighbor.center));
   }
   void AddNeighbor(Node neighbor, Wall wall)
   {
     neighbors.add(neighbor);
     connections.add(wall);
   }

    //Extra code to help sample the polygons with walls
    ArrayList<Wall> createBorder(PVector center, float border)
    {
      ArrayList<Wall> borders = new ArrayList<Wall>();
    
      PVector topLeft = new PVector(center.x - border, center.y - border);
      PVector bottomLeft = new PVector(center.x - border, center.y + border);
      PVector bottomRight = new PVector(center.x + border, center.y + border);
      PVector topRight = new PVector(center.x + border, center.y - border);
    
      borders.add(new Wall(topLeft, bottomLeft));
      borders.add(new Wall(bottomLeft, bottomRight));
      borders.add(new Wall(bottomRight, topRight));
      borders.add(new Wall(topRight, topLeft));
    
      return borders;
    }
}

class NavMesh
{   
   public ArrayList<PVector> ReflexPoints;
   public ArrayList<Wall> NewWalls;
   public ArrayList<PVector> MidPoint;
   //HashMap<Integer, Wall> NewWallsMap = new HashMap<Integer, Wall>();
   public ArrayList<Node> RandData;      //Artificially created data
   public ArrayList<PVector> holyGrail;  //path to be followed
   
   //Node that contains our convex polygons
   public ArrayList<Node> vex;
   
   //Finds the middle of our polygons. We will need to call this for every polygon
   PVector findMiddle(Node node)
   {
     PVector temp = new PVector (0,0);
     int i = 0;
     for(i = 0; i < node.polygon.size(); i++)
     {
       temp = PVector.add(temp, node.polygon.get(i).start);
     }
     temp = PVector.div(temp, i);
     return temp;
   }
   
   
   void bake(Map map)
   {
       //Creating a couple nodes and connections for artificial testing
       RandData = new ArrayList<Node>();
       RandData.add(new Node(0, new PVector(50, 490)));
       RandData.add(new Node(1, new PVector(500, 100)));
       RandData.add(new Node(2, new PVector(230, 500)));
       RandData.add(new Node(3, new PVector(20, 30)));
       RandData.add(new Node(4, new PVector(750, 300)));
       RandData.add(new Node(5, new PVector(400, 300)));
      
       RandData.get(0).AddNeighbor(RandData.get(2));
       RandData.get(2).AddNeighbor(RandData.get(0));
       RandData.get(0).AddNeighbor(RandData.get(3));
       RandData.get(3).AddNeighbor(RandData.get(0));
       RandData.get(1).AddNeighbor(RandData.get(4));
       RandData.get(4).AddNeighbor(RandData.get(1));
       RandData.get(5).AddNeighbor(RandData.get(3));
       RandData.get(3).AddNeighbor(RandData.get(5));
       RandData.get(1).AddNeighbor(RandData.get(5));
       RandData.get(5).AddNeighbor(RandData.get(1));
       RandData.get(2).AddNeighbor(RandData.get(5));
       RandData.get(5).AddNeighbor(RandData.get(2));
       RandData.get(4).AddNeighbor(RandData.get(2));
       RandData.get(2).AddNeighbor(RandData.get(4));
      
           
       ArrayList<Wall> Walls = map.walls;
       NewWalls = new ArrayList<Wall>();
       ReflexPoints = new ArrayList<PVector>();
       
       stroke(0,255,0);
       if(Walls != null)
       {
         for(int i = 0; i<Walls.size(); ++i)
         {
           int next = (i+1)%Walls.size();
           if(Walls.get(i).normal.dot(Walls.get(next).direction) >= 0)
           {
             ReflexPoints.add(Walls.get(i).end);
           }
         }
       } 
      
       //might add and if reflexive != null
       //If there are reflexpoints, we split
       if (ReflexPoints.size() > 0)
       {
        vex = Split(Walls); 
       }
               
 
     //finding path between the start and a designated point here, issue with calling it from boid seek
       holyGrail = new ArrayList<PVector>();
       holyGrail = findPath(billy.kinematic.position, new PVector(760, 310));
     
     //prints out the path generated by A*
     /*print("\n Path in order\n");
       for(int i = 0; i < holyGrail.size(); i++)
       {
         print((i + 1)+ " Point: is at " + holyGrail.get(i));
         print("\n");
       }
       */
   }
   
   //Split command, takes in a wall list as an input. Will split the map into smaller polygons
   ArrayList<Node> Split(ArrayList<Wall> PolygonWalls)
   {
     //This is for split command
     ArrayList<Node> polyList = new ArrayList<Node>();
     //find reflexive point
     int ReflexPointNumber = -1;
     boolean Convex = true;
    
     //For loop. Cycles through the polygon wall list. If there's a reflex point, it adds it to the list of reflex points
     for(int i = 0; i<PolygonWalls.size(); ++i){
           int next = (i+1)%PolygonWalls.size();
           if(PolygonWalls.get(i).normal.dot(PolygonWalls.get(next).direction) >= 0)
           {
             print("\nReflex found");
             ReflexPointNumber = next;
             Convex = false;
             break;
           }
         }
     
     print("\nReflex Point Number: " + ReflexPointNumber);    
     
     //Checks whether or not the newly constructed polygon is convex.
     if(Convex)
     {
       print("\nFound Convex Polygon");
       Node nodeConvex = new Node(tag, PolygonWalls);
       tag++;
       polyList.add(nodeConvex);
       //Create new polygon, no reflex points found
     }  
     
     else 
     { //Going to need to split it again
       PVector ReflexPoint = PolygonWalls.get(ReflexPointNumber).start;
       
       //Need to find a point to fix at
       int FixPointNumber = 0;    //just need to initialize these variables, a valid fix point should always be found in our loop
       PVector FixPoint = ReflexPoint;
       
       int PointGap = 2;      //Points between start and fix, starts by skipping the point we know is reflex already
       boolean Reachable = false;
       boolean Reflexive = true;
       
       //While loop to make sure that
       while(Reachable == false || Reflexive == false)
       {
         Reachable = true;
         Reflexive = true;
         
         FixPointNumber = (ReflexPointNumber+PointGap)%PolygonWalls.size();
         FixPoint = PolygonWalls.get(FixPointNumber).start;
         Wall TestWall = new Wall(ReflexPoint, FixPoint);
         
         if(!IsPlaceable(PolygonWalls, TestWall)){
           Reachable = false;
         }
         
         int Previous = (ReflexPointNumber-1);
         if(Previous <0){
           Previous = PolygonWalls.size() -1;
         }
         if(PolygonWalls.get(Previous).normal.dot(TestWall.direction) >= 0){    //Checks if the new wall will fix the initial reflexive point
              Reflexive = false;
         }
         else
         {
          //print("\nA non reflexive wall could be formed between points " + ReflexPointNumber + " and " + FixPointNumber);
         }
         
         //print(" infinte looping ");
         PointGap += 1;
       }

       print("\nSplitting the polygon between points " + ReflexPoint + ", " + FixPoint);
       if(FixPointNumber < ReflexPointNumber)
       {
         int temp = FixPointNumber;
         FixPointNumber = ReflexPointNumber;
         ReflexPointNumber = temp;
         ReflexPoint = PolygonWalls.get(ReflexPointNumber).start;
         FixPoint = PolygonWalls.get(FixPointNumber).start;
       }
       
       Wall Normal = new Wall(ReflexPoint, FixPoint); //This would be the wall with a positive ID
       Normal.id = tag;
       Wall Reverse = new Wall(FixPoint, ReflexPoint); //This would be the wall with a negative ID
       Normal.id = -tag;
       tag++;
                   
       ArrayList<Wall> FrontWalls = new ArrayList<Wall>();
       ArrayList<Wall> BackWalls = new ArrayList<Wall>(); 
       BackWalls.add(Reverse);
       //Loops through the polygon list, will figure out if it's a back or front wall.           
       for(int r = 0; r<PolygonWalls.size(); r++)
       { 
           if(r >= ReflexPointNumber && r < FixPointNumber)
           {
             BackWalls.add(PolygonWalls.get(r));
             //print("\nAdding to backwall wall: " + r);
           } else{
             FrontWalls.add(PolygonWalls.get(r));
             //print("\nAdding to frontwall wall: " + r);
           }
         
       }
       FrontWalls.add(ReflexPointNumber, Normal);
       NewWalls.add(Normal); 
       
       print("\nPrinting the front wall list");
       PrintWallCoords(FrontWalls);
       //print("\nSplitting the front Wall");
       
       ArrayList<Node> tracker = Split(FrontWalls);
       
       
       //print("\nPrinting the back wall list");
       //PrintWallCoords(BackWalls);
       //print("\nSplitting the back Wall");
       ArrayList<Node> trackerNeg = Split(BackWalls);
       
       for (Node n: tracker)
       {
         for (Node m: trackerNeg)
         {
            for (Wall o: n.polygon)
           {
             for (Wall p: m.polygon)
             {
              if (o.id == -p.id)
              {
                n.AddNeighbor(m, o);
                m.AddNeighbor(n, o);
              }
             }
           }
         }
       }
       polyList.addAll(tracker);
       polyList.addAll(trackerNeg);
     }
     return polyList;
   }  
     /*
     //creates a wall and reverse wall with the same numbers but one is negative
     //creates two new sets of walls
       //finds by matching removing all the walls between the reflexive and fix point on the original wall, and adds the reverse wall to that list
         //the non inverted wall is inserted to the position that the previous walls were just removed from
       //calls split() on both polygons
     //somehow add the connections, or save the splitting edge to a global list that they can be compared against later
           }
           else{
             //if no reflexive points are found a convex polygon has been created
             //create an ID and initialize the polygon as a node class
             
           }
         }
     */
   
   
   Boolean IsPlaceable (ArrayList<Wall> PolygonWalls, Wall TestWall){
     PVector From = PVector.add(TestWall.start, PVector.mult(TestWall.direction, 0.01));
     PVector To = PVector.add(TestWall.end, PVector.mult(TestWall.direction, -0.01));
     for(int n = 0; n<PolygonWalls.size(); n++){      //checks all walls to see if there is any crossing
           if(PolygonWalls.get(n).crosses(From, To)){
             return false;
           }
         }
     return true;
   }
   
   //Navemesh navigation section
   ArrayList<PVector> findPath(PVector start, PVector destination)
   {
      /// implement A* to find a path
      ArrayList<PVector> result = null;
      return result;
   }
   
   //Sections for drawing navmesh and circling reflex points.
   void update(float dt)
   {
      draw();
      
       //print("\n List all points: " + AllPoints);
       //print("\n List all reflex points: " + RPoints);
      
   }
   
   void draw()
   {
      /// use this to draw the nav mesh graph
      for(int i = 0; i < ReflexPoints.size(); i++)
      {
        stroke(0,255,0);
        circle(ReflexPoints.get(i).x, ReflexPoints.get(i).y, 20);
      }
      
      //Polygon Midpoints
      for(int i = 0; i < ReflexPoints.size(); i++)
      {
        stroke(0,255,0);
        circle(findMiddle(vex.get(i)).x, findMiddle(vex.get(i)).y, 20);
      }
      
      if(NewWalls!=null)
      {
        for(int j = 0; j < NewWalls.size(); j++)
        {
          stroke(0,0,255);
          line(NewWalls.get(j).start.x, NewWalls.get(j).start.y, NewWalls.get(j).end.x, NewWalls.get(j).end.y);
            //line(current.x, current.y, current.x + 50, current.y);
        }
      }
   }
}
